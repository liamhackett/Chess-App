{"ast":null,"code":"import { samePosition } from \"../../Constants\";\nimport { tileIsOccupied, tileIsEmptyOrOccupiedByOpponent, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const queenMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  // if (desiredPosition.x === initialPosition.x || desiredPosition.y === initialPosition.y){\n  //     return this.queenMove(initialPosition, desiredPosition, type, team, boardState);\n  // }\n  // else{\n  //     return this.bishopMove(initialPosition, desiredPosition, type, team, boardState);\n\n  // }\n  for (let i = 1; i < 8; i++) {\n    const multiplierX = desiredPosition.x < initialPosition.x ? -1 : desiredPosition.x > initialPosition.x ? 1 : 0;\n    const multiplierY = desiredPosition.y < initialPosition.y ? -1 : desiredPosition.y > initialPosition.y ? 1 : 0;\n    let passedPosition = {\n      x: initialPosition.x + i * multiplierX,\n      y: initialPosition.y + i * multiplierY\n    };\n    if (samePosition(passedPosition, desiredPosition)) {\n      return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleQueenMoves = (queen, boardState) => {\n  const possibleMoves = [];\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: queen.position.x,\n      y: queen.position.y + i\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: queen.position.x + i,\n      y: queen.position.y\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: queen.position.x,\n      y: queen.position.y - i\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: queen.position.x - i,\n      y: queen.position.y\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, queen.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["samePosition","tileIsOccupied","tileIsEmptyOrOccupiedByOpponent","tileIsOccupiedByOpponent","queenMove","initialPosition","desiredPosition","type","team","boardState","i","multiplierX","x","multiplierY","y","passedPosition","getPossibleQueenMoves","queen","possibleMoves","destination","position","push"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/QueenRules.ts"],"sourcesContent":["import { samePosition, PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsOccupied, tileIsEmptyOrOccupiedByOpponent, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const queenMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    // if (desiredPosition.x === initialPosition.x || desiredPosition.y === initialPosition.y){\n    //     return this.queenMove(initialPosition, desiredPosition, type, team, boardState);\n    // }\n    // else{\n    //     return this.bishopMove(initialPosition, desiredPosition, type, team, boardState);\n\n    // }\n    for(let i = 1; i < 8; i++){\n        const multiplierX = desiredPosition.x < initialPosition.x ? -1 : desiredPosition.x > initialPosition.x ? 1 : 0;\n\n        const multiplierY = desiredPosition.y < initialPosition.y ? -1 : desiredPosition.y > initialPosition.y ? 1 : 0;\n        \n        let passedPosition: Position = {x: initialPosition.x + (i * multiplierX), y: initialPosition.y + (i * multiplierY)};\n\n        if(samePosition(passedPosition, desiredPosition)){\n            return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        }\n        else{\n            if(tileIsOccupied(passedPosition, boardState)){\n                break;\n            }\n        }\n    }\n\n    return false;\n}\n\nexport const getPossibleQueenMoves = (queen: Piece, boardState: Piece[]) : Position[] => {\n    const possibleMoves: Position[] = [];\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: queen.position.x, y: queen.position.y + i};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, queen.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: queen.position.x + i, y: queen.position.y};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, queen.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: queen.position.x, y: queen.position.y - i};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, queen.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: queen.position.x - i, y: queen.position.y};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, queen.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n\n    return possibleMoves;\n    \n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}