{"ast":null,"code":"import { PieceType, TeamType } from \"../../Constants\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const pawnMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n  // Forward movement\n  if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState);\n  }\n\n  // Normal forward movement\n  if (desiredPosition.x === initialPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState);\n  }\n\n  // Taking a piece diagonally\n  if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\nexport const isEnPassantMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n  // upper left or upper right || bottom left or bottom right\n  // if a piece is under or above the attacked tile\n\n  if (type == PieceType.PAWN) {\n    if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1) && desiredPosition.y - initialPosition.y === pawnDirection) {\n      const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n      if (piece) {\n        return true;\n      }\n    }\n  }\n  return false;\n};","map":{"version":3,"names":["PieceType","TeamType","tileIsOccupied","tileIsOccupiedByOpponent","pawnMove","initialPosition","desiredPosition","type","team","boardState","specialRow","OUR","pawnDirection","y","x","Math","abs","isEnPassantMove","PAWN","piece","find","p","position","enPassant"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    \n    // Forward movement\n    if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n        return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({ x: desiredPosition.x, y: desiredPosition.y - pawnDirection }, boardState);\n    }\n    \n    // Normal forward movement\n    if (desiredPosition.x === initialPosition.x && (desiredPosition.y - initialPosition.y === pawnDirection)) {\n        return !tileIsOccupied(desiredPosition, boardState);\n    }\n    \n    // Taking a piece diagonally\n    if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n        return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n\n    return false;\n}\n\nexport const isEnPassantMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n    const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n   \n    // upper left or upper right || bottom left or bottom right\n    // if a piece is under or above the attacked tile\n\n    if (type == PieceType.PAWN){\n        if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n            const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n            if(piece){\n                return true;\n            }\n        }\n    }\n   \n   return false;\n}"],"mappings":"AAAA,SAASA,SAAS,EAAEC,QAAQ,QAAyB,iBAAiB;AAEtE,SAASC,cAAc,EAAEC,wBAAwB,QAAQ,gBAAgB;AAEzE,OAAO,MAAMC,QAAQ,GAAGA,CAACC,eAAyB,EAAEC,eAAyB,EAAEC,IAAe,EAAEC,IAAc,EAAEC,UAAmB,KAAc;EAC7I,MAAMC,UAAU,GAAGF,IAAI,KAAKP,QAAQ,CAACU,GAAG,GAAG,CAAC,GAAG,CAAC;EAChD,MAAMC,aAAa,GAAGJ,IAAI,KAAKP,QAAQ,CAACU,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;;EAEpD;EACA,IAAIN,eAAe,CAACQ,CAAC,KAAKH,UAAU,IAAIJ,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,KAAK,CAAC,GAAGD,aAAa,EAAE;IACjG,OAAO,CAACV,cAAc,CAACI,eAAe,EAAEG,UAAU,CAAC,IAAI,CAACP,cAAc,CAAC;MAAEY,CAAC,EAAER,eAAe,CAACQ,CAAC;MAAED,CAAC,EAAEP,eAAe,CAACO,CAAC,GAAGD;IAAc,CAAC,EAAEH,UAAU,CAAC;EACtJ;;EAEA;EACA,IAAIH,eAAe,CAACQ,CAAC,KAAKT,eAAe,CAACS,CAAC,IAAKR,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,KAAKD,aAAc,EAAE;IACtG,OAAO,CAACV,cAAc,CAACI,eAAe,EAAEG,UAAU,CAAC;EACvD;;EAEA;EACA,IAAIM,IAAI,CAACC,GAAG,CAACV,eAAe,CAACQ,CAAC,GAAGT,eAAe,CAACS,CAAC,CAAC,KAAK,CAAC,IAAIR,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,KAAKD,aAAa,EAAE;IAClH,OAAOT,wBAAwB,CAACG,eAAe,EAAEG,UAAU,EAAED,IAAI,CAAC;EACtE;EAEA,OAAO,KAAK;AAChB,CAAC;AAED,OAAO,MAAMS,eAAe,GAAGA,CAACZ,eAAyB,EAAEC,eAAyB,EAAEC,IAAe,EAAEC,IAAc,EAAEC,UAAmB,KAAc;EACpJ,MAAMG,aAAa,GAAIJ,IAAI,KAAKP,QAAQ,CAACU,GAAG,GAAI,CAAC,GAAE,CAAC,CAAC;;EAErD;EACA;;EAEA,IAAIJ,IAAI,IAAIP,SAAS,CAACkB,IAAI,EAAC;IACvB,IAAI,CAACZ,eAAe,CAACQ,CAAC,GAAGT,eAAe,CAACS,CAAC,KAAK,CAAC,CAAC,IAAIR,eAAe,CAACQ,CAAC,GAAGT,eAAe,CAACS,CAAC,KAAK,CAAC,KAAIR,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,KAAKD,aAAa,EAAC;MACxJ,MAAMO,KAAK,GAAGV,UAAU,CAACW,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAACR,CAAC,KAAKR,eAAe,CAACQ,CAAC,IAAIO,CAAC,CAACC,QAAQ,CAACT,CAAC,KAAKP,eAAe,CAACO,CAAC,GAAGD,aAAa,IAAIS,CAAC,CAACE,SAAS,CAAC;MAC3I,IAAGJ,KAAK,EAAC;QACL,OAAO,IAAI;MACf;IACJ;EACJ;EAED,OAAO,KAAK;AACf,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}