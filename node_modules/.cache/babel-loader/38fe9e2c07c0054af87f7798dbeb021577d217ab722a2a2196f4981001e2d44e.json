{"ast":null,"code":"import { PieceType, TeamType } from \"../Constants\";\nexport default class Referee {\n  tileIsEmptyOrOccupiedByOpponent(position, boardState, team) {\n    return !this.tileIsOccupied(position, boardState) || this.tileIsOccupiedByOpponent(position, boardState, team);\n  }\n  tileIsOccupied(position, boardState) {\n    const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y);\n    if (piece) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  tileIsOccupiedByOpponent(position, boardState, team) {\n    const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y && p.team !== team);\n    if (piece) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  isEnPassantMove(initialPosition, desiredPosition, type, team, boardState) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    // upper left or upper right || bottom left or bottom right\n    // if a piece is under or above the attacked tile\n\n    if (type == PieceType.PAWN) {\n      if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1) && desiredPosition.y - initialPosition.y === pawnDirection) {\n        const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n        if (piece) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  isValidMove(initialPosition, desiredPosition, type, team, boardState) {\n    // console.log(\"Ref is checking move\");\n    // console.log(`\"Previous Location: ${px} ${py}`);\n    // console.log(`\"Current Location: ${x} ${y}`);\n    // console.log(`Piece Type: ${type}`);\n    // console.log(`Team: ${team}`);\n\n    // pawn movement \n    if (type === PieceType.PAWN) {\n      const specialRow = team === TeamType.OUR ? 1 : 6;\n      const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n      // forward movement\n      if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n        return !this.tileIsOccupied(desiredPosition, boardState) && !this.tileIsOccupied({\n          x: desiredPosition.x,\n          y: desiredPosition.y - pawnDirection\n        }, boardState);\n      } else if (initialPosition.x === desiredPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n        return !this.tileIsOccupied(desiredPosition, boardState);\n      }\n\n      // taking a piece\n      else if (desiredPosition.x - initialPosition.x === -1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n        // attack in upper or bottom left corner\n        if (this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n          return true;\n        }\n      } else if (desiredPosition.x - initialPosition.x === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n        // attack in upper or bottom right corner\n        if (this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n          return true;\n        }\n      }\n    } else if (type === PieceType.KNIGHT) {\n      // KNIGHT MOVING LOGIC\n      // 8 Different moving patterns\n      for (let i = -1; i < 2; i += 2) {\n        for (let j = -1; j < 2; j += 2) {\n          if (desiredPosition.y - initialPosition.y === i * 2) {\n            if (desiredPosition.x - initialPosition.x === j) {\n              return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n          } else if (desiredPosition.x - initialPosition.x === i * 2) {\n            if (desiredPosition.y - initialPosition.y === j) {\n              return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n            }\n          }\n        }\n      }\n    } else if (type === PieceType.BISHOP) {\n      // BISHOP MOVING AND ATTACK LOGIC\n\n      for (let i = 1; i < 8; i++) {\n        // up right\n        if (desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x + i,\n            y: initialPosition.y + i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // bottom right\n        if (desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x + i,\n            y: initialPosition.y - i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n        // top left\n        if (desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x - i,\n            y: initialPosition.y + i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // bottom left\n        if (desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x - i,\n            y: initialPosition.y - i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n      }\n      return false;\n    } else if (type === PieceType.ROOK) {\n      // ROOK MOVING AND ATTACK LOGIC\n\n      for (let i = 1; i < 8; i++) {\n        // Right\n        if (desiredPosition.x > initialPosition.x && desiredPosition.y === initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x + i,\n            y: initialPosition.y\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // Forward\n        if (desiredPosition.x === initialPosition.x && desiredPosition.y > initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x,\n            y: initialPosition.y + i\n          };\n          // check if tile is destination tile\n          if (passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n        // Left\n        if (desiredPosition.x < initialPosition.x && desiredPosition.y === initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x - i,\n            y: initialPosition.y\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // Backwards\n        if (desiredPosition.x === initialPosition.x && desiredPosition.y < initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x,\n            y: initialPosition.y - i\n          };\n          // check if tile is destination tile\n          if (passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n      }\n      return false;\n    } else if (type === PieceType.QUEEN) {\n      // Queen MOVING AND ATTACK LOGIC\n\n      for (let i = 1; i < 8; i++) {\n        // up right\n        if (desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x + i,\n            y: initialPosition.y + i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // bottom right\n        if (desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x + i,\n            y: initialPosition.y - i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // top left\n        if (desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x - i,\n            y: initialPosition.y + i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // bottom left\n        if (desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x - i,\n            y: initialPosition.y - i\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // right\n        if (desiredPosition.x > initialPosition.x && desiredPosition.y === initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x + i,\n            y: initialPosition.y\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // forward\n        if (desiredPosition.x === initialPosition.x && desiredPosition.y > initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x,\n            y: initialPosition.y + i\n          };\n          // check if tile is destination tile\n          if (passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n        // left\n        if (desiredPosition.x < initialPosition.x && desiredPosition.y === initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x - i,\n            y: initialPosition.y\n          };\n          // check if tile is destination tile\n          if (passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n\n        // backwards\n        if (desiredPosition.x === initialPosition.x && desiredPosition.y < initialPosition.y) {\n          let passedPosition = {\n            x: initialPosition.x,\n            y: initialPosition.y - i\n          };\n          // check if tile is destination tile\n          if (passedPosition.y === desiredPosition.y) {\n            return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n          }\n          // passing tile\n          else {\n            if (this.tileIsOccupied(passedPosition, boardState)) {\n              break;\n            }\n          }\n        }\n      }\n      return false;\n    } else if (type === PieceType.KING) {\n      // Move 1 in any direction then if the rook is still in the position and the path is clear allow castling\n      // Also king cannot move into a check and cannot castle if it has moved and passes through a check\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["PieceType","TeamType","Referee","tileIsEmptyOrOccupiedByOpponent","position","boardState","team","tileIsOccupied","tileIsOccupiedByOpponent","piece","find","p","x","y","isEnPassantMove","initialPosition","desiredPosition","type","pawnDirection","OUR","PAWN","enPassant","isValidMove","specialRow","KNIGHT","i","j","BISHOP","passedPosition","ROOK","QUEEN","KING"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/Referee.ts"],"sourcesContent":["import { PieceType, TeamType , Piece, Position} from \"../Constants\";\n\nexport default class Referee {\n    tileIsEmptyOrOccupiedByOpponent(position: Position, boardState: Piece[], team: TeamType): boolean{\n        return !this.tileIsOccupied(position, boardState) || this.tileIsOccupiedByOpponent(position, boardState, team);\n    }\n    tileIsOccupied(position: Position, boardState: Piece[]): boolean {\n        const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y);\n        if(piece){\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    tileIsOccupiedByOpponent(position: Position, boardState: Piece[], team: TeamType): boolean {\n        const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y && p.team !== team);\n        if (piece) {\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\n    isEnPassantMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]){\n        const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n       \n        // upper left or upper right || bottom left or bottom right\n        // if a piece is under or above the attacked tile\n\n        if (type == PieceType.PAWN){\n            if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n                const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n                if(piece){\n                    return true;\n                }\n            }\n            \n        }\n       \n       return false;\n    }\n\n    isValidMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) {\n        // console.log(\"Ref is checking move\");\n        // console.log(`\"Previous Location: ${px} ${py}`);\n        // console.log(`\"Current Location: ${x} ${y}`);\n        // console.log(`Piece Type: ${type}`);\n        // console.log(`Team: ${team}`);\n\n        // pawn movement \n        if (type === PieceType.PAWN){\n            const specialRow = (team === TeamType.OUR) ? 1: 6;\n            const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n            \n            // forward movement\n            if(initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 *pawnDirection){\n                return !this.tileIsOccupied(desiredPosition, boardState) && !this.tileIsOccupied({x : desiredPosition.x, y: desiredPosition.y - pawnDirection}, boardState);\n            }\n            else if(initialPosition.x === desiredPosition.x && (desiredPosition.y - initialPosition.y === pawnDirection)){\n                    return !this.tileIsOccupied(desiredPosition, boardState);\n                        \n            }\n            \n            // taking a piece\n            else if (desiredPosition.x - initialPosition.x === -1 && desiredPosition.y - initialPosition.y === pawnDirection){\n                // attack in upper or bottom left corner\n                if(this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)){\n                    return true;\n                }\n            }\n            else if (desiredPosition.x - initialPosition.x === 1 && desiredPosition.y - initialPosition.y === pawnDirection){\n                // attack in upper or bottom right corner\n                if(this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)){\n                    return true;\n                }\n            }\n        }\n        else if (type === PieceType.KNIGHT){\n            // KNIGHT MOVING LOGIC\n            // 8 Different moving patterns\n            for(let i = -1; i < 2; i+=2){\n                for(let j = -1; j < 2; j+=2){\n                    if (desiredPosition.y - initialPosition.y === i * 2){\n                        if (desiredPosition.x - initialPosition.x === j){\n                            return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n                            \n                        }\n                    }\n                    else if (desiredPosition.x - initialPosition.x === i * 2){\n                        if(desiredPosition.y - initialPosition.y === j){\n                            return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n                        }\n                    }\n                }\n            }\n        }\n        else if (type === PieceType.BISHOP){\n            // BISHOP MOVING AND ATTACK LOGIC\n        \n            for (let i = 1; i < 8; i++){\n\n                // up right\n                if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y + i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                    \n                }\n               \n\n                // bottom right\n                if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y - i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n                // top left\n                if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y + i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n\n                // bottom left\n                if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y - i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return false;\n            \n        }\n\n        else if (type === PieceType.ROOK){\n            // ROOK MOVING AND ATTACK LOGIC\n        \n            for (let i = 1; i < 8; i++){\n                \n\n\n\n                // Right\n                if(desiredPosition.x > initialPosition.x && desiredPosition.y === initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n            \n                // Forward\n                if(desiredPosition.x === initialPosition.x && desiredPosition.y > initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y + i};\n                    // check if tile is destination tile\n                    if(passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n                // Left\n                if(desiredPosition.x < initialPosition.x && desiredPosition.y === initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n\n                // Backwards\n                if(desiredPosition.x === initialPosition.x && desiredPosition.y < initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y - i};\n                    // check if tile is destination tile\n                    if(passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        else if(type === PieceType.QUEEN) {\n            // Queen MOVING AND ATTACK LOGIC\n        \n            for (let i = 1; i < 8; i++){\n\n                // up right\n                if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y + i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                    \n                }\n               \n                // bottom right\n                if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y - i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n\n                // top left\n                if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y + i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n\n                // bottom left\n                if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y - i};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n            \n                // right\n                if(desiredPosition.x > initialPosition.x && desiredPosition.y === initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n            \n                // forward\n                if(desiredPosition.x === initialPosition.x && desiredPosition.y > initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y + i};\n                    // check if tile is destination tile\n                    if(passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n                // left\n                if(desiredPosition.x < initialPosition.x && desiredPosition.y === initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y};\n                    // check if tile is destination tile\n                    if(passedPosition.x === desiredPosition.x && passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n\n                // backwards\n                if(desiredPosition.x === initialPosition.x && desiredPosition.y < initialPosition.y) {\n                    let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y - i};\n                    // check if tile is destination tile\n                    if(passedPosition.y === desiredPosition.y){\n                        return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                    }\n                    // passing tile\n                    else{\n                        if(this.tileIsOccupied(passedPosition, boardState)){\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return false;\n        }\n        else if(type === PieceType.KING){\n            // Move 1 in any direction then if the rook is still in the position and the path is clear allow castling\n            // Also king cannot move into a check and cannot castle if it has moved and passes through a check\n        }\n\n\n        return false;\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}