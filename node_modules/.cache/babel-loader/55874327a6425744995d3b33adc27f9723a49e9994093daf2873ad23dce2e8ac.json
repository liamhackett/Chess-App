{"ast":null,"code":"import { PieceType, TeamType, samePosition } from \"../../Constants\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const pawnMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n  // Forward movement\n  if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState);\n  }\n\n  // Normal forward movement\n  if (desiredPosition.x === initialPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState);\n  }\n\n  // Taking a piece diagonally\n  if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\n\n// export const isEnPassantMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n//     const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n\n//     // upper left or upper right || bottom left or bottom right\n//     // if a piece is under or above the attacked tile\n\n//     if (type == PieceType.PAWN){\n//         if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n//             const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n//             if(piece){\n//                 return true;\n//             }\n//         }\n//     }\n\n//    return false;\n//  }\n\nexport const getPossiblePawnMoves = (pawn, boardState) => {\n  const possibleMoves = [];\n  const specialRow = pawn.team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = pawn.team === TeamType.OUR ? 1 : -1;\n  const normalMove = {\n    x: pawn.position.x,\n    y: pawn.position.y + pawnDirection\n  };\n  const specialMove = {\n    x: pawn.position.x,\n    y: pawn.position.y + pawnDirection * 2\n  };\n  const upperLeftAttack = {\n    x: pawn.position.x - 1,\n    y: pawn.position.y + pawnDirection\n  };\n  const upperRightAttack = {\n    x: pawn.position.x + 1,\n    y: pawn.position.y + pawnDirection\n  };\n  const leftPosition = {\n    x: pawn.position.x - 1,\n    y: pawn.position.y\n  };\n  const rightPosition = {\n    x: pawn.position.x + 1,\n    y: pawn.position.y\n  };\n  if (!tileIsOccupied(normalMove, boardState)) {\n    possibleMoves.push({\n      x: pawn.position.x,\n      y: pawn.position.y + pawnDirection\n    });\n    if (pawn.position.y === specialRow && !tileIsOccupied(specialMove, boardState)) {\n      possibleMoves.push({\n        x: pawn.position.x,\n        y: pawn.position.y + pawnDirection * 2\n      });\n    }\n  }\n  if (tileIsOccupiedByOpponent(upperLeftAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperLeftAttack);\n  } else if (!tileIsOccupied(upperLeftAttack, boardState)) {\n    const leftPiece = boardState.find(p => samePosition(p.position, leftPosition));\n    if (leftPiece != null && leftPiece.type == PieceType.PAWN && leftPiece.enPassant) {\n      possibleMoves.push(upperLeftAttack);\n    }\n  }\n  if (tileIsOccupiedByOpponent(upperRightAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperRightAttack);\n  } else if (!tileIsOccupied(upperRightAttack, boardState)) {\n    const rightPiece = boardState.find(p => samePosition(p.position, rightPosition));\n    if (rightPiece != null && rightPiece.type == PieceType.PAWN && rightPiece.enPassant) {\n      possibleMoves.push(up);\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["PieceType","TeamType","samePosition","tileIsOccupied","tileIsOccupiedByOpponent","pawnMove","initialPosition","desiredPosition","type","team","boardState","specialRow","OUR","pawnDirection","y","x","Math","abs","getPossiblePawnMoves","pawn","possibleMoves","normalMove","position","specialMove","upperLeftAttack","upperRightAttack","leftPosition","rightPosition","push","leftPiece","find","p","PAWN","enPassant","rightPiece","up"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { PieceType, TeamType , Piece, Position, samePosition} from \"../../Constants\";\n\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    \n    // Forward movement\n    if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n        return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({ x: desiredPosition.x, y: desiredPosition.y - pawnDirection }, boardState);\n    }\n    \n    // Normal forward movement\n    if (desiredPosition.x === initialPosition.x && (desiredPosition.y - initialPosition.y === pawnDirection)) {\n        return !tileIsOccupied(desiredPosition, boardState);\n    }\n    \n    // Taking a piece diagonally\n    if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n        return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n\n    return false;\n}\n\n// export const isEnPassantMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n//     const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n   \n//     // upper left or upper right || bottom left or bottom right\n//     // if a piece is under or above the attacked tile\n\n//     if (type == PieceType.PAWN){\n//         if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n//             const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n//             if(piece){\n//                 return true;\n//             }\n//         }\n//     }\n   \n//    return false;\n//  }\n\n\nexport const getPossiblePawnMoves = (pawn: Piece, boardState: Piece[]) : Position[] => {\n    const possibleMoves: Position[] = [];\n\n    const specialRow = pawn.team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = pawn.team === TeamType.OUR ? 1 : -1;\n    const normalMove: Position = {x: pawn.position.x, y: pawn.position.y + pawnDirection};\n    const specialMove: Position = {x: pawn.position.x, y: pawn.position.y + pawnDirection * 2};\n    const upperLeftAttack: Position = {x: pawn.position.x - 1, y: pawn.position.y + pawnDirection};\n    const upperRightAttack: Position = {x: pawn.position.x + 1, y: pawn.position.y + pawnDirection};\n\n    const leftPosition: Position = {x: pawn.position.x - 1, y: pawn.position.y};\n    const rightPosition: Position = {x: pawn.position.x + 1, y: pawn.position.y};\n\n\n    if(!tileIsOccupied(normalMove, boardState)){\n        possibleMoves.push({x: pawn.position.x, y: pawn.position.y + pawnDirection});\n\n        if(pawn.position.y === specialRow && !tileIsOccupied(specialMove, boardState)) {\n            possibleMoves.push({x: pawn.position.x, y: pawn.position.y + pawnDirection * 2});\n        }\n    }\n    \n    if(tileIsOccupiedByOpponent(upperLeftAttack,boardState,  pawn.team)){\n        possibleMoves.push(upperLeftAttack);\n    }\n    else if(!tileIsOccupied(upperLeftAttack, boardState)) {\n        const leftPiece = boardState.find(p => samePosition(p.position, leftPosition));\n        if(leftPiece != null && leftPiece.type == PieceType.PAWN && leftPiece.enPassant){\n            possibleMoves.push(upperLeftAttack);\n        }\n    }\n    if (tileIsOccupiedByOpponent(upperRightAttack, boardState, pawn.team)){\n        possibleMoves.push(upperRightAttack);\n    }\n    else if(!tileIsOccupied(upperRightAttack, boardState)) {\n        const rightPiece = boardState.find(p => samePosition(p.position, rightPosition));\n        if(rightPiece != null && rightPiece.type == PieceType.PAWN && rightPiece.enPassant){\n            possibleMoves.push(up);\n        }\n    }\n\n\n    return possibleMoves;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}