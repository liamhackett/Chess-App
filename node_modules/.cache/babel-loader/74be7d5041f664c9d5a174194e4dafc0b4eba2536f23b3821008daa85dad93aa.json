{"ast":null,"code":"import { samePosition } from \"../../Constants\";\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const kingMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  // Basic king movement\n  const multiplierX = desiredPosition.x < initialPosition.x ? -1 : desiredPosition.x > initialPosition.x ? 1 : 0;\n  const multiplierY = desiredPosition.y < initialPosition.y ? -1 : desiredPosition.y > initialPosition.y ? 1 : 0;\n  let passedPosition = {\n    x: initialPosition.x + 1 * multiplierX,\n    y: initialPosition.y + 1 * multiplierY\n  };\n  if (samePosition(passedPosition, desiredPosition)) {\n    return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n  }\n  return false;\n};\nexport const getPossibleKingMoves = (king, boardState) => {\n  const possibleMoves = [];\n  const directions = [{\n    x: 1,\n    y: 0\n  },\n  // Right\n  {\n    x: -1,\n    y: 0\n  },\n  // Left\n  {\n    x: 0,\n    y: 1\n  },\n  // Up\n  {\n    x: 0,\n    y: -1\n  },\n  // Down\n  {\n    x: 1,\n    y: 1\n  },\n  // Up-Right\n  {\n    x: -1,\n    y: 1\n  },\n  // Up-Left\n  {\n    x: 1,\n    y: -1\n  },\n  // Down-Right\n  {\n    x: -1,\n    y: -1\n  } // Down-Left\n  ];\n\n  for (const direction of directions) {\n    const destination = {\n      x: king.position.x + direction.x,\n      y: king.position.y + direction.y\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["samePosition","tileIsEmptyOrOccupiedByOpponent","tileIsOccupied","tileIsOccupiedByOpponent","kingMove","initialPosition","desiredPosition","type","team","boardState","multiplierX","x","multiplierY","y","passedPosition","getPossibleKingMoves","king","possibleMoves","directions","direction","destination","position","push"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/KingRules.ts"],"sourcesContent":["import { samePosition, PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsEmptyOrOccupiedByOpponent, tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const kingMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    // Basic king movement\n    const multiplierX = desiredPosition.x < initialPosition.x ? -1 : desiredPosition.x > initialPosition.x ? 1 : 0;\n\n    const multiplierY = desiredPosition.y < initialPosition.y ? -1 : desiredPosition.y > initialPosition.y ? 1 : 0;\n    \n    let passedPosition: Position = {x: initialPosition.x + (1 * multiplierX), y: initialPosition.y + (1 * multiplierY)};\n\n    if(samePosition(passedPosition, desiredPosition)){\n        return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    }\n\n    return false;\n}\n\nexport const getPossibleKingMoves = (king: Piece, boardState: Piece[]): Position[] => {\n    const possibleMoves: Position[] = [];\n    const directions: Position[] = [\n        { x: 1, y: 0 },   // Right\n        { x: -1, y: 0 },  // Left\n        { x: 0, y: 1 },   // Up\n        { x: 0, y: -1 },  // Down\n        { x: 1, y: 1 },   // Up-Right\n        { x: -1, y: 1 },  // Up-Left\n        { x: 1, y: -1 },  // Down-Right\n        { x: -1, y: -1 }, // Down-Left\n    ];\n\n    for (const direction of directions) {\n            const destination: Position = {\n                x: king.position.x + direction.x,\n                y: king.position.y + direction.y\n            };\n\n            if (!tileIsOccupied(destination, boardState)) {\n                possibleMoves.push(destination);\n            } else if (tileIsOccupiedByOpponent(destination, boardState, king.team)) {\n                possibleMoves.push(destination);\n                break;\n            } else {\n                break;\n            }\n    }\n    \n    return possibleMoves;\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAA8C,iBAAiB;AAEpF,SAASC,+BAA+B,EAAEC,cAAc,EAAEC,wBAAwB,QAAQ,gBAAgB;AAE1G,OAAO,MAAMC,QAAQ,GAAGA,CAACC,eAAyB,EAAEC,eAAyB,EAAEC,IAAe,EAAEC,IAAc,EAAEC,UAAmB,KAAc;EAC7I;EACA,MAAMC,WAAW,GAAGJ,eAAe,CAACK,CAAC,GAAGN,eAAe,CAACM,CAAC,GAAG,CAAC,CAAC,GAAGL,eAAe,CAACK,CAAC,GAAGN,eAAe,CAACM,CAAC,GAAG,CAAC,GAAG,CAAC;EAE9G,MAAMC,WAAW,GAAGN,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,GAAG,CAAC,CAAC,GAAGP,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,GAAG,CAAC,GAAG,CAAC;EAE9G,IAAIC,cAAwB,GAAG;IAACH,CAAC,EAAEN,eAAe,CAACM,CAAC,GAAI,CAAC,GAAGD,WAAY;IAAEG,CAAC,EAAER,eAAe,CAACQ,CAAC,GAAI,CAAC,GAAGD;EAAY,CAAC;EAEnH,IAAGZ,YAAY,CAACc,cAAc,EAAER,eAAe,CAAC,EAAC;IAC7C,OAAOL,+BAA+B,CAACa,cAAc,EAAEL,UAAU,EAAED,IAAI,CAAC;EAC5E;EAEA,OAAO,KAAK;AAChB,CAAC;AAED,OAAO,MAAMO,oBAAoB,GAAGA,CAACC,IAAW,EAAEP,UAAmB,KAAiB;EAClF,MAAMQ,aAAyB,GAAG,EAAE;EACpC,MAAMC,UAAsB,GAAG,CAC3B;IAAEP,CAAC,EAAE,CAAC;IAAEE,CAAC,EAAE;EAAE,CAAC;EAAI;EAClB;IAAEF,CAAC,EAAE,CAAC,CAAC;IAAEE,CAAC,EAAE;EAAE,CAAC;EAAG;EAClB;IAAEF,CAAC,EAAE,CAAC;IAAEE,CAAC,EAAE;EAAE,CAAC;EAAI;EAClB;IAAEF,CAAC,EAAE,CAAC;IAAEE,CAAC,EAAE,CAAC;EAAE,CAAC;EAAG;EAClB;IAAEF,CAAC,EAAE,CAAC;IAAEE,CAAC,EAAE;EAAE,CAAC;EAAI;EAClB;IAAEF,CAAC,EAAE,CAAC,CAAC;IAAEE,CAAC,EAAE;EAAE,CAAC;EAAG;EAClB;IAAEF,CAAC,EAAE,CAAC;IAAEE,CAAC,EAAE,CAAC;EAAE,CAAC;EAAG;EAClB;IAAEF,CAAC,EAAE,CAAC,CAAC;IAAEE,CAAC,EAAE,CAAC;EAAE,CAAC,CAAE;EAAA,CACrB;;EAED,KAAK,MAAMM,SAAS,IAAID,UAAU,EAAE;IAC5B,MAAME,WAAqB,GAAG;MAC1BT,CAAC,EAAEK,IAAI,CAACK,QAAQ,CAACV,CAAC,GAAGQ,SAAS,CAACR,CAAC;MAChCE,CAAC,EAAEG,IAAI,CAACK,QAAQ,CAACR,CAAC,GAAGM,SAAS,CAACN;IACnC,CAAC;IAED,IAAI,CAACX,cAAc,CAACkB,WAAW,EAAEX,UAAU,CAAC,EAAE;MAC1CQ,aAAa,CAACK,IAAI,CAACF,WAAW,CAAC;IACnC,CAAC,MAAM,IAAIjB,wBAAwB,CAACiB,WAAW,EAAEX,UAAU,EAAEO,IAAI,CAACR,IAAI,CAAC,EAAE;MACrES,aAAa,CAACK,IAAI,CAACF,WAAW,CAAC;MAC/B;IACJ,CAAC,MAAM;MACH;IACJ;EACR;EAEA,OAAOH,aAAa;AACxB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}