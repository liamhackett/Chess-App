{"ast":null,"code":"import { samePosition } from \"../../Constants\";\nimport { tileIsOccupied, tileIsEmptyOrOccupiedByOpponent, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\n// Rook function\nexport const rookMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  // ROOK MOVING AND ATTACK LOGIC\n  for (let i = 1; i < 8; i++) {\n    // Vertical Movement\n    let passedPosition;\n    if (initialPosition.x === desiredPosition.x) {\n      let multiplier = desiredPosition.y < initialPosition.y ? -1 : 1;\n      passedPosition = {\n        x: initialPosition.x,\n        y: initialPosition.y + i * multiplier\n      };\n    }\n    // Horizontal\n    else if (initialPosition.y === desiredPosition.y) {\n      let multiplier = desiredPosition.x < initialPosition.x ? -1 : 1;\n      passedPosition = {\n        x: initialPosition.x + i * multiplier,\n        y: initialPosition.y\n      };\n    }\n    if (passedPosition) {\n      if (samePosition(passedPosition, desiredPosition)) {\n        return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n      } else if (tileIsOccupied(passedPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleRookMoves = (rook, boardState) => {\n  const possibleMoves = [];\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: rook.position.x,\n      y: rook.position.y + i\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: rook.position.x + i,\n      y: rook.position.y\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: rook.position.x,\n      y: rook.position.y + i\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  for (let i = 1; i < 8; i++) {\n    const destination = {\n      x: rook.position.x,\n      y: rook.position.y + i\n    };\n    if (!tileIsOccupied(destination, boardState)) {\n      possibleMoves.push(destination);\n    } else if (tileIsOccupiedByOpponent(destination, boardState, rook.team)) {\n      possibleMoves.push(destination);\n      break;\n    } else {\n      break;\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["samePosition","tileIsOccupied","tileIsEmptyOrOccupiedByOpponent","tileIsOccupiedByOpponent","rookMove","initialPosition","desiredPosition","type","team","boardState","i","passedPosition","x","multiplier","y","getPossibleRookMoves","rook","possibleMoves","destination","position","push"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/RookRules.ts"],"sourcesContent":["import { samePosition, PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsOccupied, tileIsEmptyOrOccupiedByOpponent, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n \n // Rook function\n export const rookMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n    // ROOK MOVING AND ATTACK LOGIC\n    for (let i = 1; i < 8; i++){\n        // Vertical Movement\n        let passedPosition;\n        if(initialPosition.x === desiredPosition.x){\n            let multiplier = (desiredPosition.y < initialPosition.y) ? -1 : 1;\n            passedPosition = {x: initialPosition.x, y: initialPosition.y + (i * multiplier)};\n        }\n        // Horizontal\n        else if(initialPosition.y === desiredPosition.y){\n            let multiplier = (desiredPosition.x < initialPosition.x) ? -1 : 1;\n            passedPosition= {x: initialPosition.x + (i * multiplier), y: initialPosition.y};\n\n        }\n        if(passedPosition) {\n            if (samePosition(passedPosition, desiredPosition)) {\n                return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n            }\n            else if (tileIsOccupied(passedPosition, boardState)){\n                break;\n            }\n        }\n    }\n    \n    return false;\n\n}\n\nexport const getPossibleRookMoves = (rook: Piece, boardState: Piece[]) : Position[] => {\n    const possibleMoves: Position[] = [];\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: rook.position.x, y: rook.position.y + i};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, rook.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: rook.position.x + i, y: rook.position.y};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, rook.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: rook.position.x, y: rook.position.y + i};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, rook.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n    for (let i = 1; i < 8; i++){\n        const destination: Position = {x: rook.position.x, y: rook.position.y + i};\n\n        if(!tileIsOccupied(destination, boardState)){\n            possibleMoves.push(destination);\n        } else if(tileIsOccupiedByOpponent(destination, boardState, rook.team)){\n            possibleMoves.push(destination);\n            break;\n        }\n        else{\n            break;\n        }\n    }\n\n    return possibleMoves;\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}