{"ast":null,"code":"import { samePosition } from \"../../Constants\";\nimport { tileIsOccupied, tileIsEmptyOrOccupiedByOpponent, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\n// Bishop Function\nexport const bishopMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  // BISHOP MOVING AND ATTACK LOGIC\n\n  for (let i = 1; i < 8; i++) {\n    // diagonal \n    let multiplierX = desiredPosition.x < initialPosition.x ? -1 : 1;\n    let multiplierY = desiredPosition.y < initialPosition.y ? -1 : 1;\n    let passedPosition = {\n      x: initialPosition.x + i * multiplierX,\n      y: initialPosition.y + i * multiplierY\n    };\n    if (samePosition(passedPosition, desiredPosition)) {\n      return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    } else {\n      if (tileIsOccupied(passedPosition, boardState)) {\n        break;\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleBishopMoves = (bishop, boardState) => {\n  const directions = [{\n    x: 1,\n    y: 1\n  },\n  // Up-Right\n  {\n    x: -1,\n    y: -1\n  },\n  // Down-Left\n  {\n    x: 1,\n    y: -1\n  },\n  // Down-Right\n  {\n    x: -1,\n    y: 1\n  } // Up-Left\n  ];\n\n  const possibleMoves = [];\n  for (const direction of directions) {\n    for (let i = 1; i < 8; i++) {\n      const destination = {\n        x: bishop.position.x + direction.x * i,\n        y: bishop.position.y + direction.y * i\n      };\n      if (!tileIsOccupied(destination, boardState)) {\n        possibleMoves.push(destination);\n      } else if (tileIsOccupiedByOpponent(destination, boardState, bishop.team)) {\n        possibleMoves.push(destination);\n        break;\n      } else {\n        break;\n      }\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["samePosition","tileIsOccupied","tileIsEmptyOrOccupiedByOpponent","tileIsOccupiedByOpponent","bishopMove","initialPosition","desiredPosition","type","team","boardState","i","multiplierX","x","multiplierY","y","passedPosition","getPossibleBishopMoves","bishop","directions","possibleMoves","direction","destination","position","push"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/BishopRules.ts"],"sourcesContent":["import { samePosition, PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsOccupied, tileIsEmptyOrOccupiedByOpponent, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\n// Bishop Function\nexport const bishopMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    // BISHOP MOVING AND ATTACK LOGIC\n    \n    for (let i = 1; i < 8; i++){\n\n        // diagonal \n        let multiplierX = (desiredPosition.x < initialPosition.x) ? -1 : 1;\n        let multiplierY = (desiredPosition.y < initialPosition.y) ? -1 : 1;\n        \n        let passedPosition: Position = {x: initialPosition.x + (i * multiplierX), y: initialPosition.y + (i * multiplierY)};\n\n        if(samePosition(passedPosition, desiredPosition)){\n            return tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        }\n        else{\n            if(tileIsOccupied(passedPosition, boardState)){\n                break;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nexport const getPossibleBishopMoves = (bishop: Piece, boardState: Piece[]): Position[] => {\n    const directions: Position[] = [\n        { x: 1, y: 1 },   // Up-Right\n        { x: -1, y: -1 }, // Down-Left\n        { x: 1, y: -1 },  // Down-Right\n        { x: -1, y: 1 },  // Up-Left\n    ];\n\n    const possibleMoves: Position[] = [];\n\n    for (const direction of directions) {\n        for (let i = 1; i < 8; i++) {\n            const destination: Position = {\n                x: bishop.position.x + direction.x * i,\n                y: bishop.position.y + direction.y * i\n            };\n\n            if (!tileIsOccupied(destination, boardState)) {\n                possibleMoves.push(destination);\n            } else if (tileIsOccupiedByOpponent(destination, boardState, bishop.team)) {\n                possibleMoves.push(destination);\n                break;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return possibleMoves;\n};\n"],"mappings":"AAAA,SAASA,YAAY,QAA8C,iBAAiB;AAEpF,SAASC,cAAc,EAAEC,+BAA+B,EAAEC,wBAAwB,QAAQ,gBAAgB;;AAE1G;AACA,OAAO,MAAMC,UAAU,GAAGA,CAACC,eAAyB,EAAEC,eAAyB,EAAEC,IAAe,EAAEC,IAAc,EAAEC,UAAmB,KAAc;EAC/I;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAC;IAEvB;IACA,IAAIC,WAAW,GAAIL,eAAe,CAACM,CAAC,GAAGP,eAAe,CAACO,CAAC,GAAI,CAAC,CAAC,GAAG,CAAC;IAClE,IAAIC,WAAW,GAAIP,eAAe,CAACQ,CAAC,GAAGT,eAAe,CAACS,CAAC,GAAI,CAAC,CAAC,GAAG,CAAC;IAElE,IAAIC,cAAwB,GAAG;MAACH,CAAC,EAAEP,eAAe,CAACO,CAAC,GAAIF,CAAC,GAAGC,WAAY;MAAEG,CAAC,EAAET,eAAe,CAACS,CAAC,GAAIJ,CAAC,GAAGG;IAAY,CAAC;IAEnH,IAAGb,YAAY,CAACe,cAAc,EAAET,eAAe,CAAC,EAAC;MAC7C,OAAOJ,+BAA+B,CAACa,cAAc,EAAEN,UAAU,EAAED,IAAI,CAAC;IAC5E,CAAC,MACG;MACA,IAAGP,cAAc,CAACc,cAAc,EAAEN,UAAU,CAAC,EAAC;QAC1C;MACJ;IACJ;EACJ;EAEA,OAAO,KAAK;AAChB,CAAC;AAGD,OAAO,MAAMO,sBAAsB,GAAGA,CAACC,MAAa,EAAER,UAAmB,KAAiB;EACtF,MAAMS,UAAsB,GAAG,CAC3B;IAAEN,CAAC,EAAE,CAAC;IAAEE,CAAC,EAAE;EAAE,CAAC;EAAI;EAClB;IAAEF,CAAC,EAAE,CAAC,CAAC;IAAEE,CAAC,EAAE,CAAC;EAAE,CAAC;EAAE;EAClB;IAAEF,CAAC,EAAE,CAAC;IAAEE,CAAC,EAAE,CAAC;EAAE,CAAC;EAAG;EAClB;IAAEF,CAAC,EAAE,CAAC,CAAC;IAAEE,CAAC,EAAE;EAAE,CAAC,CAAG;EAAA,CACrB;;EAED,MAAMK,aAAyB,GAAG,EAAE;EAEpC,KAAK,MAAMC,SAAS,IAAIF,UAAU,EAAE;IAChC,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxB,MAAMW,WAAqB,GAAG;QAC1BT,CAAC,EAAEK,MAAM,CAACK,QAAQ,CAACV,CAAC,GAAGQ,SAAS,CAACR,CAAC,GAAGF,CAAC;QACtCI,CAAC,EAAEG,MAAM,CAACK,QAAQ,CAACR,CAAC,GAAGM,SAAS,CAACN,CAAC,GAAGJ;MACzC,CAAC;MAED,IAAI,CAACT,cAAc,CAACoB,WAAW,EAAEZ,UAAU,CAAC,EAAE;QAC1CU,aAAa,CAACI,IAAI,CAACF,WAAW,CAAC;MACnC,CAAC,MAAM,IAAIlB,wBAAwB,CAACkB,WAAW,EAAEZ,UAAU,EAAEQ,MAAM,CAACT,IAAI,CAAC,EAAE;QACvEW,aAAa,CAACI,IAAI,CAACF,WAAW,CAAC;QAC/B;MACJ,CAAC,MAAM;QACH;MACJ;IACJ;EACJ;EAEA,OAAOF,aAAa;AACxB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}