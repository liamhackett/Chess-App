{"ast":null,"code":"import { samePosition, PieceType, TeamType } from \"../Constants\";\nexport default class Referee {\n  tileIsEmptyOrOccupiedByOpponent(position, boardState, team) {\n    return !this.tileIsOccupied(position, boardState) || this.tileIsOccupiedByOpponent(position, boardState, team);\n  }\n  tileIsOccupied(position, boardState) {\n    const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y);\n    if (piece) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  tileIsOccupiedByOpponent(position, boardState, team) {\n    const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y && p.team !== team);\n    if (piece) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  isEnPassantMove(initialPosition, desiredPosition, type, team, boardState) {\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    // upper left or upper right || bottom left or bottom right\n    // if a piece is under or above the attacked tile\n\n    if (type == PieceType.PAWN) {\n      if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1) && desiredPosition.y - initialPosition.y === pawnDirection) {\n        const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n        if (piece) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  pawnMove(initialPosition, desiredPosition, type, team, boardState) {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n    // forward movement\n    if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n      return !this.tileIsOccupied(desiredPosition, boardState) && !this.tileIsOccupied({\n        x: desiredPosition.x,\n        y: desiredPosition.y - pawnDirection\n      }, boardState);\n    } else if (initialPosition.x === desiredPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n      return !this.tileIsOccupied(desiredPosition, boardState);\n    }\n\n    // taking a piece\n    else if (desiredPosition.x - initialPosition.x === -1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n      // attack in upper or bottom left corner\n      if (this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true;\n      }\n    } else if (desiredPosition.x - initialPosition.x === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n      // attack in upper or bottom right corner\n      if (this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)) {\n        return true;\n      }\n    }\n  }\n\n  // Knight Function\n  knightMove(initialPosition, desiredPosition, type, team, boardState) {\n    // KNIGHT MOVING LOGIC\n    // 8 Different moving patterns\n    for (let i = -1; i < 2; i += 2) {\n      for (let j = -1; j < 2; j += 2) {\n        if (desiredPosition.y - initialPosition.y === i * 2) {\n          if (desiredPosition.x - initialPosition.x === j) {\n            return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n          }\n        } else if (desiredPosition.x - initialPosition.x === i * 2) {\n          if (desiredPosition.y - initialPosition.y === j) {\n            return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n          }\n        }\n      }\n    }\n  }\n\n  // Bishop Function\n  bishopMove(initialPosition, desiredPosition, type, team, boardState) {\n    // BISHOP MOVING AND ATTACK LOGIC\n\n    for (let i = 1; i < 8; i++) {\n      // up right\n      if (desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n        let passedPosition = {\n          x: initialPosition.x + i,\n          y: initialPosition.y + i\n        };\n        // check if tile is destination tile\n        if (samePosition(passedPosition, desiredPosition)) {\n          return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        }\n        // passing tile\n        else {\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n\n      // bottom right\n      if (desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n        let passedPosition = {\n          x: initialPosition.x + i,\n          y: initialPosition.y - i\n        };\n        // check if tile is destination tile\n        if (samePosition(passedPosition, desiredPosition)) {\n          return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        }\n        // passing tile\n        else {\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n      // top left\n      if (desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n        let passedPosition = {\n          x: initialPosition.x - i,\n          y: initialPosition.y + i\n        };\n        // check if tile is destination tile\n        if (samePosition(passedPosition, desiredPosition)) {\n          return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        }\n        // passing tile\n        else {\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n\n      // bottom left\n      if (desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n        let passedPosition = {\n          x: initialPosition.x - i,\n          y: initialPosition.y - i\n        };\n        // check if tile is destination tile\n        if (samePosition(passedPosition, desiredPosition)) {\n          return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        }\n        // passing tile\n        else {\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Rook function\n  rookMove(initialPosition, desiredPosition, type, team, boardState) {\n    // ROOK MOVING AND ATTACK LOGIC\n    if (initialPosition.x === desiredPosition.x) {\n      for (let i = 1; i < 8; i++) {\n        // Vertical Movement\n        let multiplier = desiredPosition.y < initialPosition.y ? -1 : 1;\n        let passedPosition = {\n          x: initialPosition.x,\n          y: initialPosition.y + i * multiplier\n        };\n        if (samePosition(passedPosition, desiredPosition)) {\n          return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        } else if (this.tileIsOccupied(passedPosition, boardState)) {\n          break;\n        }\n      }\n    }\n    // Horizontal\n    if (initialPosition.y === desiredPosition.y) {\n      for (let i = 1; i < 8; i++) {\n        let multiplier = desiredPosition.x < initialPosition.x ? -1 : 1;\n        let passedPosition = {\n          x: initialPosition.x + i * multiplier,\n          y: initialPosition.y\n        };\n        if (samePosition(passedPosition, desiredPosition)) {\n          return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        } else {\n          if (this.tileIsOccupied(passedPosition, boardState)) {\n            break;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  queenMove(initialPosition, desiredPosition, type, team, boardState) {\n    if (desiredPosition.x === initialPosition.x) {\n      return this.rookMove(initialPosition, desiredPosition, type, team, boardState);\n    }\n    if (desiredPosition.y === initialPosition.y) {\n      return this.rookMove(initialPosition, desiredPosition, type, team, boardState);\n    }\n    // for(let i = 1; i < 8; i++){\n    //     // vertical\n    //     if (desiredPosition.x === initialPosition.x){\n    //         let multiplier = (desiredPosition.y < initialPosition.y) ? -1 : 1;\n    //         let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y + (i * multiplier)};\n    //         if(samePosition(passedPosition, desiredPosition)){\n    //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //         }\n    //         else{\n    //             if(this.tileIsOccupied(passedPosition, boardState)){\n    //                 break;\n    //             }\n    //         }\n    //     }\n    //     // horizontal\n    //     if (desiredPosition.y === initialPosition.y){\n    //         let multiplier = (desiredPosition.x < initialPosition.x) ? -1 : 1;\n    //         let passedPosition: Position = {x: initialPosition.x  + (i * multiplier), y: initialPosition.y};\n    //         if(samePosition(passedPosition, desiredPosition)){\n    //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //         }\n    //         else{\n    //             if(this.tileIsOccupied(passedPosition, boardState)){\n    //                 break;\n    //             }\n    //         }\n    //     }\n\n    //     // up right\n    //     if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n    //         let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y + i};\n    //         // check if tile is destination tile\n    //         if(samePosition(passedPosition, desiredPosition)){\n    //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //         }\n    //         // passing tile\n    //         else{\n    //             if(this.tileIsOccupied(passedPosition, boardState)){\n    //                 break;\n    //             }\n    //         }\n\n    //     }\n\n    //     // bottom right\n    //     if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n    //         let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y - i};\n    //         if(samePosition(passedPosition, desiredPosition)){\n    //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //         }\n    //         else{\n    //             if(this.tileIsOccupied(passedPosition, boardState)){\n    //                 break;\n    //             }\n    //         }\n    //     }\n    //     // top left\n    //     if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n    //         let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y + i};\n    //         if(samePosition(passedPosition, desiredPosition)){\n    //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //         }\n    //         else{\n    //             if(this.tileIsOccupied(passedPosition, boardState)){\n    //                 break;\n    //             }\n    //         }\n    //     }\n\n    //     // bottom left\n    //     if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n    //         let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y - i};\n    //         if(samePosition(passedPosition, desiredPosition)){\n    //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //         }\n    //         else{\n    //             if(this.tileIsOccupied(passedPosition, boardState)){\n    //                 break;\n    //             }\n    //         }\n    //     }\n    // }\n\n    // return false;\n  }\n\n  // Valid Move Function\n  isValidMove(initialPosition, desiredPosition, type, team, boardState) {\n    switch (type) {\n      case PieceType.PAWN:\n        return this.pawnMove(initialPosition, desiredPosition, type, team, boardState);\n      case PieceType.KNIGHT:\n        return this.knightMove(initialPosition, desiredPosition, type, team, boardState);\n      case PieceType.BISHOP:\n        return this.bishopMove(initialPosition, desiredPosition, type, team, boardState);\n      case PieceType.ROOK:\n        return this.rookMove(initialPosition, desiredPosition, type, team, boardState);\n      case PieceType.QUEEN:\n        return this.queenMove(initialPosition, desiredPosition, type, team, boardState);\n      case PieceType.KING:\n        console.log(\"King\");\n        break;\n    }\n\n    // if(type === PieceType.QUEEN) {\n    //     // Queen MOVING AND ATTACK LOGIC\n\n    //     for (let i = 1; i < 8; i++){\n\n    //         // up right\n    //         if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y + i};\n    //             // check if tile is destination tile\n    //             if(samePosition(passedPosition, desiredPosition)){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n\n    //         }\n\n    //         // bottom right\n    //         if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y - i};\n    //             // check if tile is destination tile\n    //             if(samePosition(passedPosition, desiredPosition)){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n    //         }\n\n    //         // top left\n    //         if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y + i};\n    //             // check if tile is destination tile\n    //             if(samePosition(passedPosition, desiredPosition)){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n    //         }\n\n    //         // bottom left\n    //         if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y - i};\n    //             // check if tile is destination tile\n    //             if(samePosition(passedPosition, desiredPosition)){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n    //         }\n\n    //         // right\n    //         if(desiredPosition.x > initialPosition.x && desiredPosition.y === initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y};\n    //             // check if tile is destination tile\n    //             if(passedPosition.x === desiredPosition.x){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n    //         }\n\n    //         // forward\n    //         if(desiredPosition.x === initialPosition.x && desiredPosition.y > initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y + i};\n    //             // check if tile is destination tile\n    //             if(passedPosition.y === desiredPosition.y){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n    //         }\n    //         // left\n    //         if(desiredPosition.x < initialPosition.x && desiredPosition.y === initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y};\n    //             // check if tile is destination tile\n    //             if(samePosition(passedPosition, desiredPosition)){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n    //         }\n\n    //         // backwards\n    //         if(desiredPosition.x === initialPosition.x && desiredPosition.y < initialPosition.y) {\n    //             let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y - i};\n    //             // check if tile is destination tile\n    //             if(passedPosition.y === desiredPosition.y){\n    //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n    //             }\n    //             // passing tile\n    //             else{\n    //                 if(this.tileIsOccupied(passedPosition, boardState)){\n    //                     break;\n    //                 }\n    //             }\n    //         }\n    //     }\n\n    //     return false;\n    // }\n    // else if(type === PieceType.KING){\n    //     // Move 1 in any direction then if the rook is still in the position and the path is clear allow castling\n    //     // Also king cannot move into a check and cannot castle if it has moved and passes through a check\n    // }\n\n    return false;\n  }\n}","map":{"version":3,"names":["samePosition","PieceType","TeamType","Referee","tileIsEmptyOrOccupiedByOpponent","position","boardState","team","tileIsOccupied","tileIsOccupiedByOpponent","piece","find","p","x","y","isEnPassantMove","initialPosition","desiredPosition","type","pawnDirection","OUR","PAWN","enPassant","pawnMove","specialRow","knightMove","i","j","bishopMove","passedPosition","rookMove","multiplier","queenMove","isValidMove","KNIGHT","BISHOP","ROOK","QUEEN","KING","console","log"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/Referee.ts"],"sourcesContent":["import { samePosition, PieceType, TeamType , Piece, Position} from \"../Constants\";\n\nexport default class Referee {\n    tileIsEmptyOrOccupiedByOpponent(position: Position, boardState: Piece[], team: TeamType): boolean{\n        return !this.tileIsOccupied(position, boardState) || this.tileIsOccupiedByOpponent(position, boardState, team);\n    }\n    tileIsOccupied(position: Position, boardState: Piece[]): boolean {\n        const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y);\n        if(piece){\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    tileIsOccupiedByOpponent(position: Position, boardState: Piece[], team: TeamType): boolean {\n        const piece = boardState.find(p => p.position.x === position.x && p.position.y === position.y && p.team !== team);\n        if (piece) {\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\n    isEnPassantMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]){\n        const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n       \n        // upper left or upper right || bottom left or bottom right\n        // if a piece is under or above the attacked tile\n\n        if (type == PieceType.PAWN){\n            if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n                const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n                if(piece){\n                    return true;\n                }\n            }\n            \n        }\n       \n       return false;\n    }\n\n    pawnMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]){\n        const specialRow = (team === TeamType.OUR) ? 1: 6;\n        const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n        \n        // forward movement\n        if(initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 *pawnDirection){\n            return !this.tileIsOccupied(desiredPosition, boardState) && !this.tileIsOccupied({x : desiredPosition.x, y: desiredPosition.y - pawnDirection}, boardState);\n        }\n        else if(initialPosition.x === desiredPosition.x && (desiredPosition.y - initialPosition.y === pawnDirection)){\n                return !this.tileIsOccupied(desiredPosition, boardState);\n                    \n        }\n        \n        // taking a piece\n        else if (desiredPosition.x - initialPosition.x === -1 && desiredPosition.y - initialPosition.y === pawnDirection){\n            // attack in upper or bottom left corner\n            if(this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)){\n                return true;\n            }\n        }\n        else if (desiredPosition.x - initialPosition.x === 1 && desiredPosition.y - initialPosition.y === pawnDirection){\n            // attack in upper or bottom right corner\n            if(this.tileIsOccupiedByOpponent(desiredPosition, boardState, team)){\n                return true;\n            }\n        }\n    }\n    \n    // Knight Function\n    knightMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) {\n        // KNIGHT MOVING LOGIC\n        // 8 Different moving patterns\n        for(let i = -1; i < 2; i+=2){\n            for(let j = -1; j < 2; j+=2){\n                if (desiredPosition.y - initialPosition.y === i * 2){\n                    if (desiredPosition.x - initialPosition.x === j){\n                        return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n                        \n                    }\n                }\n                else if (desiredPosition.x - initialPosition.x === i * 2){\n                    if(desiredPosition.y - initialPosition.y === j){\n                        return this.tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n                    }\n                }\n            }\n        }\n    }\n\n    // Bishop Function\n    bishopMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) {\n        // BISHOP MOVING AND ATTACK LOGIC\n        \n        for (let i = 1; i < 8; i++){\n\n            // up right\n            if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n                let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y + i};\n                // check if tile is destination tile\n                if(samePosition(passedPosition, desiredPosition)){\n                    return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                }\n                // passing tile\n                else{\n                    if(this.tileIsOccupied(passedPosition, boardState)){\n                        break;\n                    }\n                }\n                \n            }\n           \n\n            // bottom right\n            if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n                let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y - i};\n                // check if tile is destination tile\n                if(samePosition(passedPosition, desiredPosition)){\n                    return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                }\n                // passing tile\n                else{\n                    if(this.tileIsOccupied(passedPosition, boardState)){\n                        break;\n                    }\n                }\n            }\n            // top left\n            if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n                let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y + i};\n                // check if tile is destination tile\n                if(samePosition(passedPosition, desiredPosition)){\n                    return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                }\n                // passing tile\n                else{\n                    if(this.tileIsOccupied(passedPosition, boardState)){\n                        break;\n                    }\n                }\n            }\n\n            // bottom left\n            if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n                let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y - i};\n                // check if tile is destination tile\n                if(samePosition(passedPosition, desiredPosition)){\n                    return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                }\n                // passing tile\n                else{\n                    if(this.tileIsOccupied(passedPosition, boardState)){\n                        break;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Rook function\n    rookMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) {\n        // ROOK MOVING AND ATTACK LOGIC\n        if(initialPosition.x === desiredPosition.x){\n            for (let i = 1; i < 8; i++){\n\n                // Vertical Movement\n                let multiplier = (desiredPosition.y < initialPosition.y) ? -1 : 1;\n\n                let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y + (i * multiplier)};\n\n                if (samePosition(passedPosition, desiredPosition)) {\n                    return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                }\n                else if (this.tileIsOccupied(passedPosition, boardState)){\n                    break;\n                }\n\n            }\n        }\n        // Horizontal\n        if(initialPosition.y === desiredPosition.y){\n            for (let i = 1; i < 8; i++){\n                let multiplier = (desiredPosition.x < initialPosition.x) ? -1 : 1;\n\n                let passedPosition: Position = {x: initialPosition.x + (i * multiplier), y: initialPosition.y};\n                if (samePosition(passedPosition, desiredPosition)) {\n                    return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n                }\n                else {\n                    if (this.tileIsOccupied(passedPosition, boardState)){\n                        break;\n                    }\n                }\n\n            }\n        }\n        \n        return false;\n    \n    }\n\n    queenMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) {\n        if (desiredPosition.x === initialPosition.x){\n            return this.rookMove(initialPosition, desiredPosition, type, team, boardState);\n        }\n        if (desiredPosition.y === initialPosition.y){\n            return this.rookMove(initialPosition, desiredPosition, type, team, boardState);\n        }\n        // for(let i = 1; i < 8; i++){\n        //     // vertical\n        //     if (desiredPosition.x === initialPosition.x){\n        //         let multiplier = (desiredPosition.y < initialPosition.y) ? -1 : 1;\n        //         let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y + (i * multiplier)};\n        //         if(samePosition(passedPosition, desiredPosition)){\n        //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //         }\n        //         else{\n        //             if(this.tileIsOccupied(passedPosition, boardState)){\n        //                 break;\n        //             }\n        //         }\n        //     }\n        //     // horizontal\n        //     if (desiredPosition.y === initialPosition.y){\n        //         let multiplier = (desiredPosition.x < initialPosition.x) ? -1 : 1;\n        //         let passedPosition: Position = {x: initialPosition.x  + (i * multiplier), y: initialPosition.y};\n        //         if(samePosition(passedPosition, desiredPosition)){\n        //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //         }\n        //         else{\n        //             if(this.tileIsOccupied(passedPosition, boardState)){\n        //                 break;\n        //             }\n        //         }\n        //     }\n\n        //     // up right\n        //     if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n        //         let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y + i};\n        //         // check if tile is destination tile\n        //         if(samePosition(passedPosition, desiredPosition)){\n        //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //         }\n        //         // passing tile\n        //         else{\n        //             if(this.tileIsOccupied(passedPosition, boardState)){\n        //                 break;\n        //             }\n        //         }\n                \n        //     }\n           \n\n        //     // bottom right\n        //     if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n        //         let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y - i};\n        //         if(samePosition(passedPosition, desiredPosition)){\n        //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //         }\n        //         else{\n        //             if(this.tileIsOccupied(passedPosition, boardState)){\n        //                 break;\n        //             }\n        //         }\n        //     }\n        //     // top left\n        //     if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n        //         let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y + i};\n        //         if(samePosition(passedPosition, desiredPosition)){\n        //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //         }\n        //         else{\n        //             if(this.tileIsOccupied(passedPosition, boardState)){\n        //                 break;\n        //             }\n        //         }\n        //     }\n\n        //     // bottom left\n        //     if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n        //         let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y - i};\n        //         if(samePosition(passedPosition, desiredPosition)){\n        //             return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //         }\n        //         else{\n        //             if(this.tileIsOccupied(passedPosition, boardState)){\n        //                 break;\n        //             }\n        //         }\n        //     }\n        // }\n        \n        \n        // return false;\n    }\n    \n\n\n    // Valid Move Function\n    isValidMove(initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) {\n\n        switch(type) {\n            case PieceType.PAWN:\n                return this.pawnMove(initialPosition, desiredPosition, type, team, boardState);\n            \n                case PieceType.KNIGHT:\n                return this.knightMove(initialPosition, desiredPosition, type, team, boardState);\n            \n            case PieceType.BISHOP:\n                return this.bishopMove(initialPosition, desiredPosition, type, team, boardState);\n            \n            case PieceType.ROOK:\n                return this.rookMove(initialPosition, desiredPosition, type, team, boardState);\n            \n            case PieceType.QUEEN:\n                return this.queenMove(initialPosition, desiredPosition, type, team, boardState);\n            \n            case PieceType.KING:\n                console.log(\"King\");\n                break;\n        }\n        \n        \n        // if(type === PieceType.QUEEN) {\n        //     // Queen MOVING AND ATTACK LOGIC\n        \n        //     for (let i = 1; i < 8; i++){\n\n        //         // up right\n        //         if(desiredPosition.x > initialPosition.x && desiredPosition.y > initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y + i};\n        //             // check if tile is destination tile\n        //             if(samePosition(passedPosition, desiredPosition)){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n                    \n        //         }\n               \n        //         // bottom right\n        //         if(desiredPosition.x > initialPosition.x && desiredPosition.y < initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y - i};\n        //             // check if tile is destination tile\n        //             if(samePosition(passedPosition, desiredPosition)){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n        //         }\n\n        //         // top left\n        //         if(desiredPosition.x < initialPosition.x && desiredPosition.y > initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y + i};\n        //             // check if tile is destination tile\n        //             if(samePosition(passedPosition, desiredPosition)){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n        //         }\n\n        //         // bottom left\n        //         if(desiredPosition.x < initialPosition.x && desiredPosition.y < initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y - i};\n        //             // check if tile is destination tile\n        //             if(samePosition(passedPosition, desiredPosition)){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n        //         }\n            \n        //         // right\n        //         if(desiredPosition.x > initialPosition.x && desiredPosition.y === initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x + i, y: initialPosition.y};\n        //             // check if tile is destination tile\n        //             if(passedPosition.x === desiredPosition.x){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n        //         }\n            \n        //         // forward\n        //         if(desiredPosition.x === initialPosition.x && desiredPosition.y > initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y + i};\n        //             // check if tile is destination tile\n        //             if(passedPosition.y === desiredPosition.y){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n        //         }\n        //         // left\n        //         if(desiredPosition.x < initialPosition.x && desiredPosition.y === initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x - i, y: initialPosition.y};\n        //             // check if tile is destination tile\n        //             if(samePosition(passedPosition, desiredPosition)){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n        //         }\n\n        //         // backwards\n        //         if(desiredPosition.x === initialPosition.x && desiredPosition.y < initialPosition.y) {\n        //             let passedPosition: Position = {x: initialPosition.x, y: initialPosition.y - i};\n        //             // check if tile is destination tile\n        //             if(passedPosition.y === desiredPosition.y){\n        //                 return this.tileIsEmptyOrOccupiedByOpponent(passedPosition, boardState, team);\n        //             }\n        //             // passing tile\n        //             else{\n        //                 if(this.tileIsOccupied(passedPosition, boardState)){\n        //                     break;\n        //                 }\n        //             }\n        //         }\n        //     }\n\n        //     return false;\n        // }\n        // else if(type === PieceType.KING){\n        //     // Move 1 in any direction then if the rook is still in the position and the path is clear allow castling\n        //     // Also king cannot move into a check and cannot castle if it has moved and passes through a check\n        // }\n\n\n        return false;\n    }\n}"],"mappings":"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ACA;IACA;;IAEA;;IAGA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAGA;EACJ;;EAIA;EACA2B,WAAWA,CAACjB,eAAyB,EAAEC,eAAyB,EAAEC,IAAe,EAAEX,IAAc,EAAED,UAAmB,EAAE;IAEpH,QAAOY,IAAI;MACP,KAAKjB,SAAS,CAACoB,IAAI;QACf,OAAO,IAAI,CAACE,QAAQ,CAACP,eAAe,EAAEC,eAAe,EAAEC,IAAI,EAAEX,IAAI,EAAED,UAAU,CAAC;MAE9E,KAAKL,SAAS,CAACiC,MAAM;QACrB,OAAO,IAAI,CAACT,UAAU,CAACT,eAAe,EAAEC,eAAe,EAAEC,IAAI,EAAEX,IAAI,EAAED,UAAU,CAAC;MAEpF,KAAKL,SAAS,CAACkC,MAAM;QACjB,OAAO,IAAI,CAACP,UAAU,CAACZ,eAAe,EAAEC,eAAe,EAAEC,IAAI,EAAEX,IAAI,EAAED,UAAU,CAAC;MAEpF,KAAKL,SAAS,CAACmC,IAAI;QACf,OAAO,IAAI,CAACN,QAAQ,CAACd,eAAe,EAAEC,eAAe,EAAEC,IAAI,EAAEX,IAAI,EAAED,UAAU,CAAC;MAElF,KAAKL,SAAS,CAACoC,KAAK;QAChB,OAAO,IAAI,CAACL,SAAS,CAAChB,eAAe,EAAEC,eAAe,EAAEC,IAAI,EAAEX,IAAI,EAAED,UAAU,CAAC;MAEnF,KAAKL,SAAS,CAACqC,IAAI;QACfC,OAAO,CAACC,GAAG,CAAC,MAAM,CAAC;QACnB;IACR;;IAGA;IACA;;IAEA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;;IAGA,OAAO,KAAK;EAChB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}