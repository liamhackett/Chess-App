{"ast":null,"code":"import { TeamType } from \"../../Constants\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const pawnMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n  // Forward movement\n  if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState);\n  }\n\n  // Normal forward movement\n  if (desiredPosition.x === initialPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState);\n  }\n\n  // Taking a piece diagonally\n  if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\n\n// export const isEnPassantMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n//     const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n\n//     // upper left or upper right || bottom left or bottom right\n//     // if a piece is under or above the attacked tile\n\n//     if (type == PieceType.PAWN){\n//         if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n//             const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n//             if(piece){\n//                 return true;\n//             }\n//         }\n//     }\n\n//    return false;\n//  }\n\nexport const getPossiblePawnMoves = (pawn, boardState) => {\n  const possibleMoves = [];\n  const specialRow = pawn.team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = pawn.team === TeamType.OUR ? 1 : -1;\n  if (!tileIsOccupied({\n    x: pawn.position.x,\n    y: pawn.position.y + pawnDirection\n  }, boardState)) {\n    possibleMoves.push({\n      x: pawn.position.x,\n      y: pawn.position.y + pawnDirection\n    });\n    if (pawn.position.y === specialRow && !tileIsOccupied({\n      x: pawn.position.x,\n      y: pawn.position.y + pawnDirection * 2\n    }, boardState)) {\n      possibleMoves.push({\n        x: pawn.position.x,\n        y: pawn.position.y + pawnDirection * 2\n      });\n    }\n  }\n\n  // if(tileIsOccupiedByOpponent({x: pawn.position.x + 1, y: pawn.position.y + pawnDirection},boardState,  pawn.team)){\n  //     possibleMoves.push({x: pawn.position.x + 1, y: pawn.position.y + pawnDirection})\n  // }\n  // else if (tileIsOccupiedByOpponent({x: pawn.position.x - 1, y: pawn.position.y + pawnDirection}, boardState, pawn.team)){\n  //     possibleMoves.push({x: pawn.position.x - 1, y: pawn.position.y + pawnDirection})\n  // }\n\n  return possibleMoves;\n};","map":{"version":3,"names":["TeamType","tileIsOccupied","tileIsOccupiedByOpponent","pawnMove","initialPosition","desiredPosition","type","team","boardState","specialRow","OUR","pawnDirection","y","x","Math","abs","getPossiblePawnMoves","pawn","possibleMoves","position","push"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    \n    // Forward movement\n    if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n        return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({ x: desiredPosition.x, y: desiredPosition.y - pawnDirection }, boardState);\n    }\n    \n    // Normal forward movement\n    if (desiredPosition.x === initialPosition.x && (desiredPosition.y - initialPosition.y === pawnDirection)) {\n        return !tileIsOccupied(desiredPosition, boardState);\n    }\n    \n    // Taking a piece diagonally\n    if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n        return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n\n    return false;\n}\n\n// export const isEnPassantMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n//     const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n   \n//     // upper left or upper right || bottom left or bottom right\n//     // if a piece is under or above the attacked tile\n\n//     if (type == PieceType.PAWN){\n//         if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n//             const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n//             if(piece){\n//                 return true;\n//             }\n//         }\n//     }\n   \n//    return false;\n//  }\n\n\nexport const getPossiblePawnMoves = (pawn: Piece, boardState: Piece[]) : Position[] => {\n    const possibleMoves: Position[] = [];\n\n    const specialRow = pawn.team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = pawn.team === TeamType.OUR ? 1 : -1;\n\n    if(!tileIsOccupied({x: pawn.position.x, y: pawn.position.y + pawnDirection}, boardState)){\n        possibleMoves.push({x: pawn.position.x, y: pawn.position.y + pawnDirection});\n\n        if(pawn.position.y === specialRow && !tileIsOccupied({x: pawn.position.x, y: pawn.position.y + pawnDirection * 2}, boardState)) {\n            possibleMoves.push({x: pawn.position.x, y: pawn.position.y + pawnDirection * 2});\n        }\n    }\n    \n    // if(tileIsOccupiedByOpponent({x: pawn.position.x + 1, y: pawn.position.y + pawnDirection},boardState,  pawn.team)){\n    //     possibleMoves.push({x: pawn.position.x + 1, y: pawn.position.y + pawnDirection})\n    // }\n    // else if (tileIsOccupiedByOpponent({x: pawn.position.x - 1, y: pawn.position.y + pawnDirection}, boardState, pawn.team)){\n    //     possibleMoves.push({x: pawn.position.x - 1, y: pawn.position.y + pawnDirection})\n    // }\n\n\n    return possibleMoves;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}