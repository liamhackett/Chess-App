{"ast":null,"code":"import { TeamType } from \"../../Constants\";\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\nexport const pawnMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  const specialRow = team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = team === TeamType.OUR ? 1 : -1;\n\n  // Forward movement\n  if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({\n      x: desiredPosition.x,\n      y: desiredPosition.y - pawnDirection\n    }, boardState);\n  }\n\n  // Normal forward movement\n  if (desiredPosition.x === initialPosition.x && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return !tileIsOccupied(desiredPosition, boardState);\n  }\n\n  // Taking a piece diagonally\n  if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n    return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n  }\n  return false;\n};\n\n// export const isEnPassantMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n//     const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n\n//     // upper left or upper right || bottom left or bottom right\n//     // if a piece is under or above the attacked tile\n\n//     if (type == PieceType.PAWN){\n//         if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n//             const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n//             if(piece){\n//                 return true;\n//             }\n//         }\n//     }\n\n//    return false;\n//  }\n\nexport const getPossiblePawnMoves = (pawn, boardState) => {\n  const possibleMoves = [];\n  const specialRow = pawn.team === TeamType.OUR ? 1 : 6;\n  const pawnDirection = pawn.team === TeamType.OUR ? 1 : -1;\n  const normalMove = {\n    x: pawn.position.x,\n    y: pawn.position.y + pawnDirection\n  };\n  const specialMove = {\n    x: pawn.position.x,\n    y: pawn.position.y + pawnDirection * 2\n  };\n  const upperLeftAttack = {\n    x: pawn.position.x - 1,\n    y: pawn.position.y + pawnDirection\n  };\n  const upperRightAttack = {\n    x: pawn.position.x + 1,\n    y: pawn.position.y + pawnDirection\n  };\n  const leftPosition = {\n    x: pawn.position.x,\n    y: pawn.position.y + pawnDirection\n  };\n  if (!tileIsOccupied(normalMove, boardState)) {\n    possibleMoves.push({\n      x: pawn.position.x,\n      y: pawn.position.y + pawnDirection\n    });\n    if (pawn.position.y === specialRow && !tileIsOccupied(specialMove, boardState)) {\n      possibleMoves.push({\n        x: pawn.position.x,\n        y: pawn.position.y + pawnDirection * 2\n      });\n    }\n  }\n  if (tileIsOccupiedByOpponent(upperLeftAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperLeftAttack);\n  }\n  if (tileIsOccupiedByOpponent(upperRightAttack, boardState, pawn.team)) {\n    possibleMoves.push(upperRightAttack);\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["TeamType","tileIsOccupied","tileIsOccupiedByOpponent","pawnMove","initialPosition","desiredPosition","type","team","boardState","specialRow","OUR","pawnDirection","y","x","Math","abs","getPossiblePawnMoves","pawn","possibleMoves","normalMove","position","specialMove","upperLeftAttack","upperRightAttack","leftPosition","push"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/PawnRules.ts"],"sourcesContent":["import { PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsOccupied, tileIsOccupiedByOpponent } from \"./GeneralRules\";\n\nexport const pawnMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    const specialRow = team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = team === TeamType.OUR ? 1 : -1;\n    \n    // Forward movement\n    if (initialPosition.y === specialRow && desiredPosition.y - initialPosition.y === 2 * pawnDirection) {\n        return !tileIsOccupied(desiredPosition, boardState) && !tileIsOccupied({ x: desiredPosition.x, y: desiredPosition.y - pawnDirection }, boardState);\n    }\n    \n    // Normal forward movement\n    if (desiredPosition.x === initialPosition.x && (desiredPosition.y - initialPosition.y === pawnDirection)) {\n        return !tileIsOccupied(desiredPosition, boardState);\n    }\n    \n    // Taking a piece diagonally\n    if (Math.abs(desiredPosition.x - initialPosition.x) === 1 && desiredPosition.y - initialPosition.y === pawnDirection) {\n        return tileIsOccupiedByOpponent(desiredPosition, boardState, team);\n    }\n\n    return false;\n}\n\n// export const isEnPassantMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]) : boolean =>{\n//     const pawnDirection = (team === TeamType.OUR) ? 1: -1;\n   \n//     // upper left or upper right || bottom left or bottom right\n//     // if a piece is under or above the attacked tile\n\n//     if (type == PieceType.PAWN){\n//         if ((desiredPosition.x - initialPosition.x === -1 || desiredPosition.x - initialPosition.x === 1)&& desiredPosition.y - initialPosition.y === pawnDirection){\n//             const piece = boardState.find(p => p.position.x === desiredPosition.x && p.position.y === desiredPosition.y - pawnDirection && p.enPassant);\n//             if(piece){\n//                 return true;\n//             }\n//         }\n//     }\n   \n//    return false;\n//  }\n\n\nexport const getPossiblePawnMoves = (pawn: Piece, boardState: Piece[]) : Position[] => {\n    const possibleMoves: Position[] = [];\n\n    const specialRow = pawn.team === TeamType.OUR ? 1 : 6;\n    const pawnDirection = pawn.team === TeamType.OUR ? 1 : -1;\n    const normalMove: Position = {x: pawn.position.x, y: pawn.position.y + pawnDirection};\n    const specialMove: Position = {x: pawn.position.x, y: pawn.position.y + pawnDirection * 2};\n    const upperLeftAttack: Position = {x: pawn.position.x - 1, y: pawn.position.y + pawnDirection};\n    const upperRightAttack: Position = {x: pawn.position.x + 1, y: pawn.position.y + pawnDirection};\n\n    const leftPosition: Position = {x: pawn.position.x, y: pawn.position.y + pawnDirection};\n    if(!tileIsOccupied(normalMove, boardState)){\n        possibleMoves.push({x: pawn.position.x, y: pawn.position.y + pawnDirection});\n\n        if(pawn.position.y === specialRow && !tileIsOccupied(specialMove, boardState)) {\n            possibleMoves.push({x: pawn.position.x, y: pawn.position.y + pawnDirection * 2});\n        }\n    }\n    \n    if(tileIsOccupiedByOpponent(upperLeftAttack,boardState,  pawn.team)){\n        possibleMoves.push(upperLeftAttack);\n    }\n    if (tileIsOccupiedByOpponent(upperRightAttack, boardState, pawn.team)){\n        possibleMoves.push(upperRightAttack);\n    }\n\n\n    return possibleMoves;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}