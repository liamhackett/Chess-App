{"ast":null,"code":"import { tileIsEmptyOrOccupiedByOpponent } from \"./GeneralRules\";\n\n// Knight Function\nexport const knightMove = (initialPosition, desiredPosition, type, team, boardState) => {\n  // KNIGHT MOVING LOGIC\n  // 8 Different moving patterns\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      if (desiredPosition.y - initialPosition.y === i * 2) {\n        if (desiredPosition.x - initialPosition.x === j) {\n          return tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n        }\n      } else if (desiredPosition.x - initialPosition.x === i * 2) {\n        if (desiredPosition.y - initialPosition.y === j) {\n          return tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n        }\n      }\n    }\n  }\n  return false;\n};\nexport const getPossibleKnightMoves = (knight, boardState) => {\n  const possibleMoves = [];\n  for (let i = -1; i < 2; i += 2) {\n    for (let j = -1; j < 2; j += 2) {\n      const verticalMove = {\n        x: knight.position.x + j,\n        y: knight.position.y + i * 2\n      };\n      const horizontalMove = {\n        x: knight.position.x + i * 2,\n        y: knight.position.y + j\n      };\n      if (tileIsEmptyOrOccupiedByOpponent(verticalMove, boardState, knight.team)) {\n        possibleMoves.push(verticalMove);\n      }\n      if (tileIsEmptyOrOccupiedByOpponent(horizontalMove, boardState, knight.team)) {\n        possibleMoves.push(horizontalMove);\n      }\n    }\n  }\n  return possibleMoves;\n};","map":{"version":3,"names":["tileIsEmptyOrOccupiedByOpponent","knightMove","initialPosition","desiredPosition","type","team","boardState","i","j","y","x","getPossibleKnightMoves","knight","possibleMoves","verticalMove","position","horizontalMove","push"],"sources":["/Users/liamhackett/Desktop/Chess-App/src/referee/rules/KnightRules.ts"],"sourcesContent":["import { PieceType, TeamType , Piece, Position} from \"../../Constants\";\n\nimport { tileIsEmptyOrOccupiedByOpponent } from \"./GeneralRules\";\n\n// Knight Function\nexport const knightMove = (initialPosition: Position, desiredPosition: Position, type: PieceType, team: TeamType, boardState: Piece[]): boolean => {\n    // KNIGHT MOVING LOGIC\n    // 8 Different moving patterns\n    for(let i = -1; i < 2; i+=2){\n        for(let j = -1; j < 2; j+=2){\n            if (desiredPosition.y - initialPosition.y === i * 2){\n                if (desiredPosition.x - initialPosition.x === j){\n                    return tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n                    \n                }\n            }\n            else if (desiredPosition.x - initialPosition.x === i * 2){\n                if(desiredPosition.y - initialPosition.y === j){\n                    return tileIsEmptyOrOccupiedByOpponent(desiredPosition, boardState, team);\n                }\n            }\n        }\n    }\n    return false;\n}\n\nexport const getPossibleKnightMoves = (knight: Piece, boardState: Piece[]) : Position[] => {\n    const possibleMoves: Position[] = [];\n\n    for(let i = -1; i < 2; i+=2){\n        for(let j = -1; j < 2; j+=2){\n            const verticalMove: Position = {x: knight.position.x + j, y: knight.position.y + i * 2};\n            const horizontalMove: Position = {x: knight.position.x + i * 2, y: knight.position.y + j};\n            if(tileIsEmptyOrOccupiedByOpponent(verticalMove, boardState, knight.team)){\n                possibleMoves.push(verticalMove);\n            }\n            if(tileIsEmptyOrOccupiedByOpponent(horizontalMove, boardState, knight.team)){\n                possibleMoves.push(horizontalMove);\n            }\n        }\n    }\n\n\n    return possibleMoves;\n}"],"mappings":"AAEA,SAASA,+BAA+B,QAAQ,gBAAgB;;AAEhE;AACA,OAAO,MAAMC,UAAU,GAAGA,CAACC,eAAyB,EAAEC,eAAyB,EAAEC,IAAe,EAAEC,IAAc,EAAEC,UAAmB,KAAc;EAC/I;EACA;EACA,KAAI,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAE,CAAC,EAAC;IACxB,KAAI,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAE,CAAC,EAAC;MACxB,IAAIL,eAAe,CAACM,CAAC,GAAGP,eAAe,CAACO,CAAC,KAAKF,CAAC,GAAG,CAAC,EAAC;QAChD,IAAIJ,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,KAAKF,CAAC,EAAC;UAC5C,OAAOR,+BAA+B,CAACG,eAAe,EAAEG,UAAU,EAAED,IAAI,CAAC;QAE7E;MACJ,CAAC,MACI,IAAIF,eAAe,CAACO,CAAC,GAAGR,eAAe,CAACQ,CAAC,KAAKH,CAAC,GAAG,CAAC,EAAC;QACrD,IAAGJ,eAAe,CAACM,CAAC,GAAGP,eAAe,CAACO,CAAC,KAAKD,CAAC,EAAC;UAC3C,OAAOR,+BAA+B,CAACG,eAAe,EAAEG,UAAU,EAAED,IAAI,CAAC;QAC7E;MACJ;IACJ;EACJ;EACA,OAAO,KAAK;AAChB,CAAC;AAED,OAAO,MAAMM,sBAAsB,GAAGA,CAACC,MAAa,EAAEN,UAAmB,KAAkB;EACvF,MAAMO,aAAyB,GAAG,EAAE;EAEpC,KAAI,IAAIN,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAE,CAAC,EAAC;IACxB,KAAI,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAE,CAAC,EAAC;MACxB,MAAMM,YAAsB,GAAG;QAACJ,CAAC,EAAEE,MAAM,CAACG,QAAQ,CAACL,CAAC,GAAGF,CAAC;QAAEC,CAAC,EAAEG,MAAM,CAACG,QAAQ,CAACN,CAAC,GAAGF,CAAC,GAAG;MAAC,CAAC;MACvF,MAAMS,cAAwB,GAAG;QAACN,CAAC,EAAEE,MAAM,CAACG,QAAQ,CAACL,CAAC,GAAGH,CAAC,GAAG,CAAC;QAAEE,CAAC,EAAEG,MAAM,CAACG,QAAQ,CAACN,CAAC,GAAGD;MAAC,CAAC;MACzF,IAAGR,+BAA+B,CAACc,YAAY,EAAER,UAAU,EAAEM,MAAM,CAACP,IAAI,CAAC,EAAC;QACtEQ,aAAa,CAACI,IAAI,CAACH,YAAY,CAAC;MACpC;MACA,IAAGd,+BAA+B,CAACgB,cAAc,EAAEV,UAAU,EAAEM,MAAM,CAACP,IAAI,CAAC,EAAC;QACxEQ,aAAa,CAACI,IAAI,CAACD,cAAc,CAAC;MACtC;IACJ;EACJ;EAGA,OAAOH,aAAa;AACxB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}